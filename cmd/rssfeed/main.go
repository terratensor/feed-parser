package main

import (
	"context"
	"fmt"
	"log"
	"os"
	"os/signal"
	"sync"
	"time"
	"unicode/utf8"

	"github.com/terratensor/feed-parser/internal/entities/feed"
	"github.com/terratensor/feed-parser/internal/rssfeed"
	"github.com/terratensor/feed-parser/internal/storage/manticore"
)

var authorMap = map[int]string{
	1: "–ü—Ä–µ–∑–∏–¥–µ–Ω—Ç –†–æ—Å—Å–∏–π—Å–∫–æ–π –§–µ–¥–µ—Ä–∞—Ü–∏–∏",
	2: "–ú–∏–Ω–∏—Å—Ç–µ—Ä—Å—Ç–≤–æ –∏–Ω–æ—Å—Ç—Ä–∞–Ω–Ω—ã—Ö –¥–µ–ª –†–æ—Å—Å–∏–π—Å–∫–æ–π –§–µ–¥–µ—Ä–∞—Ü–∏–∏",
	3: "–ú–∏–Ω–∏—Å—Ç–µ—Ä—Å—Ç–≤–æ –æ–±–æ—Ä–æ–Ω—ã –†–æ—Å—Å–∏–π—Å–∫–æ–π –§–µ–¥–µ—Ä–∞—Ü–∏–∏",
}

func main() {

	log.Printf("Service started at %s", time.Now().Format("2006-01-02T15:04:05.000 MST"))
	ctx, _ := signal.NotifyContext(context.Background(), os.Interrupt)

	delayStr := os.Getenv("GENERATOR_DELAY")
	delay, err := time.ParseDuration(delayStr)
	if err != nil {
		delay = 15 * time.Minute
	}
	log.Printf("Delay: %s", delay)

	index := os.Getenv("MANTICORE_INDEX")
	if index == "" {
		index = "feed"
	}
	log.Printf("Index: %s", index)

	manticoreClient, err := manticore.New(index)
	if err != nil {
		log.Printf("failed to initialize manticore client: %v", err)
		os.Exit(1)
	}
	entries := feed.NewFeedStorage(manticoreClient)

	duration := 24 * 8 * time.Hour

	wg := &sync.WaitGroup{}

	for {
		wg.Add(1)
		go generateFeed(ctx, entries, duration, wg)
		wg.Wait()
		time.Sleep(delay)
	}
}

func generateFeed(ctx context.Context, entries *feed.Entries, duration time.Duration, wg *sync.WaitGroup) {

	defer wg.Done()

	limit := entries.Storage.CalculateLimitCount(duration)
	ch, err := entries.Find(ctx, duration)
	if err != nil {
		log.Fatalf("failed to find all entries: %v", err)
	}

	svoddFeed := &rssfeed.RssFeed{
		Title:       "–ü–æ–∏—Å–∫ –ø–æ —Å–∞–π—Ç–∞–º –ö—Ä–µ–º–ª—è, –ú–ò–î –∏ –ú–∏–Ω–æ–±–æ—Ä–æ–Ω—ã",
		Link:        "https://rss.feed.svodd.ru",
		Description: "–ü–æ–∏—Å–∫ –ø–æ —Å–∞–π—Ç–∞–º –ü—Ä–µ–∑–∏–¥–µ–Ω—Ç–∞ –†–æ—Å—Å–∏–∏, –ú–∏–Ω–∏—Å—Ç–µ—Ä—Å—Ç–≤–∞ –∏–Ω–æ—Å—Ç—Ä–∞–Ω–Ω—ã—Ö –¥–µ–ª –†–æ—Å—Å–∏–π—Å–∫–æ–π –§–µ–¥–µ—Ä–∞—Ü–∏–∏, –ú–∏–Ω–∏—Å—Ç–µ—Ä—Å—Ç–≤–æ –æ–±–æ—Ä–æ–Ω—ã –†–æ—Å—Å–∏–π—Å–∫–æ–π –§–µ–¥–µ—Ä–∞—Ü–∏–∏",
	}
	limitCount := 0
	itemCount := 0
	for {
		select {
		case <-ctx.Done():
			return
		case e, ok := <-ch:
			if !ok {
				return
			}

			link := makeEntryUrl(e.Url, e.Language)

			if utf8.RuneCountInString(e.Title) > 200 {
				limitCount++
				continue
			}

			// –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –≤—Å–µ –∑–∞–ø–∏—Å–∏, –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω–Ω—ã–µ –Ω–∞ —è–∑—ã–∫–µ –æ—Ç–ª–∏—á–Ω–æ–º –æ—Ç —Ä—É—Å—Å–∫–æ–≥–æ
			if e.Language != "ru" && e.Language != "" {
				limitCount++
				continue
			}

			// –°–æ–∑–¥–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç RSS
			item := &rssfeed.RssItem{
				Title:       e.Title,
				Link:        link,
				PubDate:     rssfeed.AnyTimeFormat(time.RFC1123Z, *e.Published),
				Author:      populateAuthorField(e.Author, e.ResourceID),
				Content:     e.Content,
				Description: populateDescription(e),
			}

			// –ï—Å–ª–∏ –µ—Å—Ç—å URL –∏—Å—Ç–æ—á–Ω–∏–∫–∞ –Ω–æ–≤–æ—Å—Ç–∏, –¥–æ–±–∞–≤–ª—è–µ–º –µ–≥–æ –≤ <source>
			if e.Url != "" {
				sourceName := "–û—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫" // –ó–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
				if name, ok := authorMap[e.ResourceID]; ok {
					sourceName = name // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ authorMap
				}
				item.Source = &rssfeed.RssSource{
					URL:  e.Url,      // URL –∏—Å—Ç–æ—á–Ω–∏–∫–∞ –Ω–æ–≤–æ—Å—Ç–∏
					Name: sourceName, // –ù–∞–∑–≤–∞–Ω–∏–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∞ –∏–∑ authorMap
				}
			}

			svoddFeed.Add(item)
			itemCount++
			limitCount++
		}
		if limitCount >= limit {
			break
		}
	}

	file, err := os.Create("./static/rss.xml")
	if err != nil {
		log.Printf("failed to create file: %v", err)
	}
	defer file.Close()

	err = rssfeed.WriteXML(svoddFeed, file)
	if err != nil {
		log.Printf("failed to write xml: %v", err)
	}

	log.Printf("üö© –°–æ–∑–¥–∞–Ω rss.xml. –í—Å–µ–≥–æ –∑–∞–ø–∏—Å–µ–π: %d\n", itemCount)
}

// populateDescription generates description for a feed entry.
//
// It takes a feed.Entry as parameter and returns a string.
func populateDescription(entry feed.Entry) string {
	description := entry.Summary
	if description == "" {
		description = entry.Title
	}
	return description
}

func populateAuthorField(author string, resourceID int) string {
	if val, ok := authorMap[resourceID]; ok {
		if resourceID == 3 && author != "" {
			return author
		}
		return val
	}
	return author
}

func makeEntryUrl(url string, language string) string {
	base := "https://feed.svodd.ru"
	if language != "ru" && language != "" {
		base += "/" + language
	}
	return fmt.Sprintf("%s/entry?url=%v", base, url)
}
